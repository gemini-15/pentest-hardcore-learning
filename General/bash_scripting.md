# Bash scripting notes


## General

### Declaring variables

we can declare a variable by *name=value*.

We can reference to a variable by preceding it by "$" character.

When declaring a variable, single quote and double quote does not the same purpose :

- When single quote is used, Bash interprets every enclosed character literally. example :`greeting='Hello World'`
- When double quote is used, all characters are viewed except "$", "`" and "\\" : `greeting2="New $greeting"`=>`New Hello World`.

### Command substitution

To set the value of a variable to the result of a command or a program, we place the name of the command in parentheses, preceded by a "$" :

```bash
$ user=$(whoami)

$ echo $user
kali
```

We can also use \`command\` :

```bash
$ user=`whoami`

$ echo $user
kali
```

The command substitution happens in a subshell and changes to variables in the subshell will not alter variables from the master process.

### Arguments

Here is a table summarizing the arguments:

| ***Variable Name*** | ***Description*** |
| --- | --- |
| $0  | The name of the Bash script |
| $1 - $9 | The first 9 arguments to the Bash script |
| $#  | Number of arguments passed to the Bash script |
| $@  | All arguments passed to the Bash script |
| $?  | The exit status to the most recently run process |
| $$  | The process ID of the current script |
| $USER | The username of the user running the script |
| $HOSTNAME | The hostname of the machine |
| $RANDOM | A random number |
| $LINENO | The current line in the script |

### Reading User Input

To read user input simply putting read :

```bash
echo "Write Y/n"
read answer
echo "Your answer is $answer"
```

some options :

- **-p** : allows us to specify a prompt :`read -p 'Username: ' username`
- **-s** : makes the user input silent : `read -sp 'Password: ' password`


## Conditionnal branching

### if syntax

```bash
if [ <some test> ]
then
    <actions>
elif [ <some other test> ]
then 
    <actions>
else
    <actions>
fi
```

### Common operators

| ***Operator*** | ***Description: Expression True if ...*** |
| --- | --- |
| !EXPRESSION | Negation |
| -n STRING | STRING lenght is greater than zero |
| -z STRING | STRING's lenght is equal to zero |
| STRING1 != STRING2 | STRING1 is not equal to STRING2 |
| STRING1 = STRING2 | STRING1 is equal to STRING2 |
| INTEGER1 -eq INTEGER2 | equal to |
| INTEGER1 -ne INTEGER2 | not equal |
| INTEGER1 -gt INTEGER2 | greater than |
| INTEGER1 -lt INTEGER2 | less than |
| INTEGER1 -ge INTEGER2 | greater than or equal |
| INTEGER1 -le INTEGER2 | less than or equal |
| -d FILE | FILE exists and is a directory |
| -e FILE | FILE exists |
| -r FILE | FILE has read permission |
| -s FILE | FILE exists and is not empty |
| -w FILE | FILE exists and has write permission |
| -x FILE | FILE exists and has execute permission |

## Boolean logical operations

Boolean logical operators execute commands based on whether a previous command succeeded (or return True or 0) of failed (return False or non-zero).

```bash
AND = &&  
OR = ||
```

## Loops

### For Loops

general syntax:

```bash
for var-name in <list>
do
    <action to perform>
done
```

The `for` loop will take each item in the list (in order) assign them as the value of the variable *var-name*.

To write a sequence between 1 and 10:

```bash
for i in {1..10} # or : for i in $(seq 1 10)
do
    echo 10.11.1.$i
done
```

### While Loops

general syntax:

```bash
while [ <some test> ]
do 
    <action to perform>
done
```

To re-create the previous example:

```bash
counter = 1
while [ $counter -le 10 ]
do 
    echo "10.11.1.$counter"
    ((counter++))
done
```

**the double parenthesis *(( ))*** : construct to perform arithmetic expansion and evaluation at same time.

## Functions

### general syntax 

```bash
#either
function function_name {
    commands...
}
#or 
function_name () {
    commands...
}
```

### Passing arguments to a function

```bash
pass_arg() {
    echo "The random number is: $1"
}

pass_arg $RANDOM

```

### Returning values

Bash functions do not actually allow you to return an arbitrary value in the traditional sense. Instead, a Bash function can return an exit status (zero for success, non-zero for failure) or some other arbitrary value that we can later access from the *$?* global variable.

A simple example with *$?* :

```bash
return_me() {
    return $RANDOM
}

return_me

echo "The previous function returned a value of $?"
```

The scope of a variable is simply the context in which it has meaning. By default, in BASH, a variable has a global scope. In contrast, a local variable can only be seen within the function, block of code, or subshell in which it is defined. We can overlay a global variable, giving it a local context, by preceding the declaration with the local keyword.

`local name="Joe"`
