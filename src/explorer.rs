
use core::fmt::Debug;

/// Trait Section
///
/// * can represent a bunch of paragraphs linked to a bunch of 
/// * markdown titles 
pub trait SectionDisplay {
    fn section_display(&self);
    fn box_clone(&self) -> Box<dyn SectionDisplay>;

}

#[derive(Debug, Clone)]
pub struct TextSection {
    pub path: String,
    pub content: String, 
}

impl SectionDisplay for TextSection {
    fn section_display(&self) {

    }

    fn box_clone(&self) -> Box<dyn SectionDisplay> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub struct CodeSection {
    pub path: String, 
    pub content: String, 
    pub language: String,
    pub copy: bool, 
}

impl SectionDisplay for CodeSection {
    fn section_display(&self) {
        println!("code : {:?}", self.content);
    }

    fn box_clone(&self) -> Box<dyn SectionDisplay> {
        Box::new(self.clone())
    }
}

#[derive(Debug, Clone)]
pub struct ImageSection {
    pub path: String, 
    pub filename: String,
    pub image: Vec<i8>,
}

impl SectionDisplay for ImageSection {
    fn section_display(&self) {

    }

    fn box_clone(&self) -> Box<dyn SectionDisplay> {
        Box::new(self.clone())
    }
}

impl Debug for dyn SectionDisplay {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self.section_display())
    }
}



impl Clone for Box<dyn SectionDisplay> {
    fn clone(&self) -> Self {
        self.box_clone()
    }
}

#[derive(Debug, Clone)]
pub struct ItemComponent {
    pub title : String,
    pub sections : Option<Vec<Box<dyn SectionDisplay>>>,

}

impl ItemComponent {
    pub fn new(title: &str, sections: Option<Vec<Box<dyn SectionDisplay>>>) -> ItemComponent {
        ItemComponent {
            title: title.to_string(),
            sections: sections
        }
    }

    pub fn display(&mut self) {
        for section in self.sections.as_ref().unwrap().iter() {
            section.section_display();
        }
    }
}

#[derive(Debug, Clone,)]
pub struct Explorer {
    pub items: Vec<ItemComponent>,
}

impl Explorer {
    /// Creates a new empty explorer 
    /// 
    /// Creates a vector of empty items. Does not allocate any initial buffer. 
    pub fn new() -> Explorer {
        Explorer{
            items: Vec::new()
        }
    }
    
    /// Add a new ItemComponent into the explorer. 
    /// 
    /// Adds an ItemComponent by specifying the title and sections (could be None)
    /// If no section is taken into account. 
    pub fn add(&mut self, title: &str, sections: Option<Vec<Box<dyn SectionDisplay>>>) {
        self.items.push(ItemComponent::new(title, sections))
    }   

    /// Get the titles
    /// 
    /// Returns a String vector of the titles of all the ItemComponent gathered. 
    pub fn get_titles(&mut self) -> Vec<String> {
        self.items.clone().into_iter().map(|item| item.title).collect()
    }

    /// Returns len of the items.
    pub fn len(&mut self) -> usize {
        self.items.len()
    }

    /// Clears the Explorer by clearing the Items. 
    pub fn clear(&mut self) {
        self.items.clear();
    }


}

impl Iterator for Explorer {
    type Item = ItemComponent;

    fn next(&mut self) -> Option<Self::Item> {
        self.items.pop()
    }
}